/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : TouchGFXHAL.cpp
  ******************************************************************************
  * This file is generated by TouchGFX Generator 4.19.1.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2022 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

#include <TouchGFXHAL.hpp>

/* USER CODE BEGIN TouchGFXHAL.cpp */

#include <touchgfx/hal/GPIO.hpp>
#include <touchgfx/hal/OSWrappers.hpp>
#include "main.h"
#include "FreeRTOS.h"
#include "task.h"

using namespace touchgfx;


LOCATION_PRAGMA_NOLOAD("image_abs_detection_r_buf")
uint32_t ucimage_abs_detection_r_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_abs_detection_r_buf");

LOCATION_PRAGMA_NOLOAD("image_abs_detection_w_buf")
uint32_t ucimage_abs_detection_w_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_abs_detection_w_buf");

LOCATION_PRAGMA_NOLOAD("image_background_buf")
uint32_t ucimage_background_HypRAM[480*272]  LOCATION_ATTRIBUTE_NOLOAD("image_background_buf");

LOCATION_PRAGMA_NOLOAD("image_fuelicon_r_buf")
uint32_t ucimage_fuelicon_r_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_fuelicon_r_buf");

LOCATION_PRAGMA_NOLOAD("image_fuelicon_w_buf")
uint32_t ucimage_fuelicon_w_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_fuelicon_w_buf");

LOCATION_PRAGMA_NOLOAD("image_doorsicon_r_buf")
uint32_t ucimage_doorsicon_r_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_doorsicon_r_buf");

LOCATION_PRAGMA_NOLOAD("image_doorsicon_w_buf")
uint32_t ucimage_doorsicon_w_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_doorsicon_w_buf");

LOCATION_PRAGMA_NOLOAD("image_engineoil_r_buf")
uint32_t ucimage_engineoil_r_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_engineoil_r_buf");

LOCATION_PRAGMA_NOLOAD("image_engineoil_w_buf")
uint32_t ucimage_engineoil_w_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_engineoil_w_buf");

LOCATION_PRAGMA_NOLOAD("image_enginewarning_w_buf")
uint32_t ucimage_enginewarning_w_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_enginewarning_w_buf");

LOCATION_PRAGMA_NOLOAD("image_enginewarning_y_buf")
uint32_t ucimage_enginewarning_y_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_enginewarning_y_buf");

LOCATION_PRAGMA_NOLOAD("image_fuelbar01_buf")
uint32_t ucimage_fuelbar01_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_fuelbar01_buf");

LOCATION_PRAGMA_NOLOAD("image_fuelbar02_buf")
uint32_t ucimage_fuelbar02_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_fuelbar02_buf");

LOCATION_PRAGMA_NOLOAD("image_fuelbar03_buf")
uint32_t ucimage_fuelbar03_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_fuelbar03_buf");

LOCATION_PRAGMA_NOLOAD("image_fuelbar04_buf")
uint32_t ucimage_fuelbar04_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_fuelbar04_buf");

LOCATION_PRAGMA_NOLOAD("image_fuelbar05_buf")
uint32_t ucimage_fuelbar05_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_fuelbar05_buf");

LOCATION_PRAGMA_NOLOAD("image_fuelbar06_buf")
uint32_t ucimage_fuelbar06_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_fuelbar06_buf");

LOCATION_PRAGMA_NOLOAD("image_fuelbar07_buf")
uint32_t ucimage_fuelbar07_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_fuelbar07_buf");

LOCATION_PRAGMA_NOLOAD("image_fuelbar08_buf")
uint32_t ucimage_fuelbar08_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_fuelbar08_buf");

LOCATION_PRAGMA_NOLOAD("image_fuelbar09_buf")
uint32_t ucimage_fuelbar09_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_fuelbar09_buf");

LOCATION_PRAGMA_NOLOAD("image_fuelbar10_buf")
uint32_t ucimage_fuelbar10_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_fuelbar10_buf");

LOCATION_PRAGMA_NOLOAD("image_highbeam_blue_buf")
uint32_t ucimage_highbeam_blue_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_highbeam_blue_buf");

LOCATION_PRAGMA_NOLOAD("image_highbeam_wb_buf")
uint32_t ucimage_highbeam_wb_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_highbeam_wb_buf");

LOCATION_PRAGMA_NOLOAD("image_highbeam_r_buf")
uint32_t ucimage_highbeam_r_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_highbeam_r_buf");

LOCATION_PRAGMA_NOLOAD("image_highbeam_w_buf")
uint32_t ucimage_highbeam_w_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_highbeam_w_buf");

LOCATION_PRAGMA_NOLOAD("image_leftindicator_r_buf")
uint32_t ucimage_leftindicator_r_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_leftindicator_r_buf");

LOCATION_PRAGMA_NOLOAD("image_leftindicator_w_buf")
uint32_t ucimage_leftindicator_w_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_leftindicator_w_buf");

LOCATION_PRAGMA_NOLOAD("image_lowbatteryicon_r_buf")
uint32_t ucimage_lowbatteryicon_r_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_lowbatteryicon_r_buf");

LOCATION_PRAGMA_NOLOAD("image_lowbatteryicon_w_buf")
uint32_t ucimage_lowbatteryicon_w_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_lowbatteryicon_w_buf");

LOCATION_PRAGMA_NOLOAD("image_lowbeam_r_buf")
uint32_t ucimage_lowbeam_r_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_lowbeam_r_buf");

LOCATION_PRAGMA_NOLOAD("image_lowbeam_w_buf")
uint32_t ucimage_lowbeam_w_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_lowbeam_w_buf");

LOCATION_PRAGMA_NOLOAD("image_parking_r_buf")
uint32_t ucimage_parking_r_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_parking_rr_buf");

LOCATION_PRAGMA_NOLOAD("image_parking_w_buf")
uint32_t ucimage_parking_w_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_parking_w_buf");

LOCATION_PRAGMA_NOLOAD("image_rightindicator_r_buf")
uint32_t ucimage_rightindicator_r_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_rightindicator_r_buf");

LOCATION_PRAGMA_NOLOAD("image_rightindicator_w_buf")
uint32_t ucimage_rightindicator_w_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_rightindicator_w_buf");

LOCATION_PRAGMA_NOLOAD("image_rpmbar01_buf")
uint32_t ucimage_rpmbar01_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_rpmbar01_buf");

LOCATION_PRAGMA_NOLOAD("image_rpmbar02_buf")
uint32_t ucimage_rpmbar02_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_rpmbar02_buf");

LOCATION_PRAGMA_NOLOAD("image_rpmbar03_buf")
uint32_t ucimage_rpmbar03_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_rpmbar03_buf");

LOCATION_PRAGMA_NOLOAD("image_rpmbar04_buf")
uint32_t ucimage_rpmbar04_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_rpmbar04_buf");

LOCATION_PRAGMA_NOLOAD("image_rpmbar05_buf")
uint32_t ucimage_rpmbar05_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_rpmbar05_buf");

LOCATION_PRAGMA_NOLOAD("image_rpmbar06_buf")
uint32_t ucimage_rpmbar06_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_rpmbar06_buf");

LOCATION_PRAGMA_NOLOAD("image_rpmbar07_buf")
uint32_t ucimage_rpmbar07_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_rpmbar07_buf");

LOCATION_PRAGMA_NOLOAD("image_rpmbar08_buf")
uint32_t ucimage_rpmbar08_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_rpmbar08_buf");

LOCATION_PRAGMA_NOLOAD("image_rpmbar09_buf")
uint32_t ucimage_rpmbar09_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_rpmbar09_buf");

LOCATION_PRAGMA_NOLOAD("image_rpmbar10_buf")
uint32_t ucimage_rpmbar10_HypRAM[75*128]  LOCATION_ATTRIBUTE_NOLOAD("image_rpmbar10_buf");

LOCATION_PRAGMA_NOLOAD("image_rpmicon_r_buf")
uint32_t ucimage_rpmicon_r_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_rpmicon_r_buf");

LOCATION_PRAGMA_NOLOAD("image_rpmicon_w_buf")
uint32_t ucimage_rpmicon_w_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_rpmicon_w_buf");


LOCATION_PRAGMA_NOLOAD("image_seatbelt_r_buf")
uint32_t ucimage_seatbelt_r_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_seatbelt_r_buf");

LOCATION_PRAGMA_NOLOAD("image_seatbelt_w_buf")
uint32_t ucimage_seatbelt_w_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_seatbelt_w_buf");

LOCATION_PRAGMA_NOLOAD("image_servicereminder_w_buf")
uint32_t ucimage_servicereminder_w_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_servicereminder_w_buf");

LOCATION_PRAGMA_NOLOAD("image_servicereminder_y_buf")
uint32_t ucimage_servicereminder_y_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_servicereminder_y_buf");

LOCATION_PRAGMA_NOLOAD("image_temperature_r_buf")
uint32_t ucimage_temperature_r_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_temperature_r_buf");

LOCATION_PRAGMA_NOLOAD("image_temperature_w_buf")
uint32_t ucimage_temperature_w_HypRAM[64*64]  LOCATION_ATTRIBUTE_NOLOAD("image_temperature_w_buf");


namespace
{
LOCATION_PRAGMA_NOLOAD("TouchGFX_Framebuffer")
uint32_t animationBuffer[(480 * 272 * 3 + 3) / 4] LOCATION_ATTRIBUTE_NOLOAD("TouchGFX_Framebuffer");

}



void TouchGFXHAL::initialize()
{
    // Calling parent implementation of initialize().
    //
    // To overwrite the generated implementation, omit call to parent function
    // and implemented needed functionality here.
    // Please note, HAL::initialize() must be called to initialize the framework.

    TouchGFXGeneratedHAL::initialize();

    setAnimationStorage((void*)animationBuffer);

    instrumentation.init();
    setMCUInstrumentation(&instrumentation);
    enableMCULoadCalculation(true);
}

void TouchGFXHAL::taskEntry()
{
    enableLCDControllerInterrupt();
    enableInterrupts();

    OSWrappers::waitForVSync();
    backPorchExited();

    /* Assert display enable LCD_DISP_CTRL pin */
    HAL_GPIO_WritePin(LCD_DISP_GPIO_Port, LCD_DISP_Pin, GPIO_PIN_SET);
    /* Assert back light LCD_BL_CTRL pin */
    HAL_GPIO_WritePin(LCD_BL_CTRL_GPIO_Port, LCD_BL_CTRL_Pin, GPIO_PIN_SET);

    for (;;)
    {
        OSWrappers::waitForVSync();
        backPorchExited();
    }
}

/**
 * Gets the frame buffer address used by the TFT controller.
 *
 * @return The address of the frame buffer currently being displayed on the TFT.
 */
uint16_t* TouchGFXHAL::getTFTFrameBuffer() const
{
    // Calling parent implementation of getTFTFrameBuffer().
    //
    // To overwrite the generated implementation, omit call to parent function
    // and implemented needed functionality here.

    return TouchGFXGeneratedHAL::getTFTFrameBuffer();
}

/**
 * Sets the frame buffer address used by the TFT controller.
 *
 * @param [in] address New frame buffer address.
 */
void TouchGFXHAL::setTFTFrameBuffer(uint16_t* address)
{
    // Calling parent implementation of setTFTFrameBuffer(uint16_t* address).
    //
    // To overwrite the generated implementation, omit call to parent function
    // and implemented needed functionality here.

    TouchGFXGeneratedHAL::setTFTFrameBuffer(address);
}

/**
 * This function is called whenever the framework has performed a partial draw.
 *
 * @param rect The area of the screen that has been drawn, expressed in absolute coordinates.
 *
 * @see flushFrameBuffer().
 */
void TouchGFXHAL::flushFrameBuffer(const touchgfx::Rect& rect)
{
    // Calling parent implementation of flushFrameBuffer(const touchgfx::Rect& rect).
    //
    // To overwrite the generated implementation, omit call to parent function
    // and implemented needed functionality here.
    // Please note, HAL::flushFrameBuffer(const touchgfx::Rect& rect) must
    // be called to notify the touchgfx framework that flush has been performed.

    TouchGFXGeneratedHAL::flushFrameBuffer(rect);

    // If the framebuffer is placed in Write Through cached memory (e.g. SRAM) then we need
    // to flush the Dcache to make sure framebuffer is correct in RAM. That's done
    // using SCB_CleanInvalidateDCache().

    SCB_CleanInvalidateDCache();
}

/**
 * Configures the interrupts relevant for TouchGFX. This primarily entails setting
 * the interrupt priorities for the DMA and LCD interrupts.
 */
void TouchGFXHAL::configureInterrupts()
{
    // Calling parent implementation of configureInterrupts().
    //
    // To overwrite the generated implementation, omit call to parent function
    // and implemented needed functionality here.

    TouchGFXGeneratedHAL::configureInterrupts();
}

/**
 * Used for enabling interrupts set in configureInterrupts()
 */
void TouchGFXHAL::enableInterrupts()
{
    // Calling parent implementation of enableInterrupts().
    //
    // To overwrite the generated implementation, omit call to parent function
    // and implemented needed functionality here.

    TouchGFXGeneratedHAL::enableInterrupts();
}

/**
 * Used for disabling interrupts set in configureInterrupts()
 */
void TouchGFXHAL::disableInterrupts()
{
    // Calling parent implementation of disableInterrupts().
    //
    // To overwrite the generated implementation, omit call to parent function
    // and implemented needed functionality here.

    TouchGFXGeneratedHAL::disableInterrupts();
}

/**
 * Configure the LCD controller to fire interrupts at VSYNC. Called automatically
 * once TouchGFX initialization has completed.
 */
void TouchGFXHAL::enableLCDControllerInterrupt()
{
    // Calling parent implementation of enableLCDControllerInterrupt().
    //
    // To overwrite the generated implementation, omit call to parent function
    // and implemented needed functionality here.

    TouchGFXGeneratedHAL::enableLCDControllerInterrupt();
}

extern "C"
{
    portBASE_TYPE IdleTaskHook(void* p)
    {
        if ((int)p) //idle task sched out
        {
            touchgfx::HAL::getInstance()->setMCUActive(true);
        }
        else //idle task sched in
        {
            touchgfx::HAL::getInstance()->setMCUActive(false);
        }
        return pdTRUE;
    }
}

/* USER CODE END TouchGFXHAL.cpp */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
